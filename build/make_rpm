#!/usr/bin/env python
import argparse
import glob
import os
import sys
import re
import subprocess


PACKAGE_NAME = "msi-persistent-id"
RPM_ROOT = '/root/rpmbuild'


def extract_irods_version(composite_path):
    composite = os.path.basename(composite_path)
    res = re.match('^centos7_([0-9]+)_([0-9]+)_([0-9]+)$', composite)
    if res is not None:
        return "{0}.{1}.{2}".format(res.group(1),
                                    res.group(2),
                                    res.group(3))


def determine_git_time_stamp():
    cmd = ["git", "log", "-1", "--date=raw"]
    cwd = os.path.dirname(__file__)
    p = subprocess.Popen(cmd,
                         stdout=subprocess.PIPE,
                         stderr=sys.stderr,
                         cwd=cwd)
    stdout, stderr = p.communicate()
    exit_code = p.poll()
    if exit_code != 0:
        raise Exception(" ".join(cmd) +
                        "exited with code {0}".format(exit_code))
    dtg = 0
    for line in stdout.split('\n'):
        m = re.match('Date: *([0-9]+)', line)
        if m:
            dtg = m.group(1)
            break
    return dtg


def determine_version(branch=None):
    if branch is None:
        cmd = ["git", "rev-parse", "--abbrev-ref", "HEAD"]
        cwd = os.path.dirname(__file__)
        p = subprocess.Popen(cmd,
                             stdout=subprocess.PIPE,
                             stderr=sys.stderr,
                             cwd=cwd)
        stdout, stderr = p.communicate()
        exit_code = p.poll()
        if exit_code != 0:
            raise Exception(" ".join(cmd) +
                            "exited with code {0}".format(exit_code))
        rev = stdout.strip()
    else:
        rev = branch
    tags_match = re.match('^v([0-9]+\\.[0-9]+\\.[0-9]+)$', rev)
    if not tags_match:
        # is a feature branch
        dtg = determine_git_time_stamp()
        package_suffix = "-{0}".format(rev)
        return (package_suffix, dtg)
    else:
        # is a release
        return ('', rev.group(1))


def docker_exec_cmd(docker_exec, inside_cmd):
    cmd = docker_exec + inside_cmd
    p = subprocess.Popen(cmd,
                         stdout=subprocess.PIPE,
                         stderr=sys.stderr)
    stdout, stderr = p.communicate()
    exit_code = p.poll()
    if exit_code != 0:
        raise Exception(" ".join(cmd) +
                        "exited with code {0}".format(exit_code))


def main():
    basedir = os.path.dirname(os.path.realpath(__file__))
    repodir = os.path.dirname(basedir)
    pattern = os.path.join(basedir, "centos7_*")
    paths = glob.glob(pattern)
    irods_versions = [extract_irods_version(p)
                      for p in paths
                      if extract_irods_version(p)]
    parser = argparse.ArgumentParser(description='Package microservice in rpm')
    parser.add_argument('--irods-version', choices=irods_versions)
    parser.add_argument('--version',
                        help="""version of the package,
                                if empty determined from git""")
    parser.add_argument('--branch',
                        help="branch of the project")
    args = parser.parse_args()
    err = False
    if args.irods_version is None:
        print("argument --irods-version required")
        err = True
    if args.version is None:
        package_suffix, version = determine_version(branch=args.branch)
    else:
        package_suffix = ""
        version = args.version
    if not re.match('^[0-9]+\\.[0-9]+\\.[0-9]+$|[0-9]+$', version):
        print(("invalid version {0}, " +
               "not in the form MAJOR.MINOR.PATCH_LEVEL").format(version))
        err = True
    if err:
        sys.exit(8)
    irods_version = args.irods_version
    container_name = "centos7_{0}_icat_1".format(irods_version.replace('.',
                                                                       '_'))
    if container_name.startswith('centos7'):
        create_dir = ['RPMS',
                      'CentOS',
                      '7',
                      'irods-{0}'.format(irods_version)]
        rpm_dir = os.path.join(repodir, *create_dir)
        rpm_dir_inside = os.path.join('/build/', *create_dir)

    docker_exec = ["docker", "exec", container_name]
    package = PACKAGE_NAME + package_suffix
    print("irods version:  {0}".format(args.irods_version))
    print("msi version:    {0}".format(version))
    print("container name: {0}".format(container_name))
    print("package:        {0}".format(package))
    print("docker exec:    {0}".format(" ".join(docker_exec)))
    print("repodir:        {0}".format(repodir))
    print("rpm_dir:        {0}".format(rpm_dir))
    if not os.path.exists(rpm_dir):
        os.makedirs(rpm_dir)

    docker_exec_cmd(docker_exec,
                    ['rpmdev-setuptree'])
    docker_exec_cmd(docker_exec,
                    ['tar', '--transform',
                     "s/build/{0}-{1}/".format(package, version),
                     '-cvzf',
                     '{0}/SOURCES/{1}-{2}.tar.gz'.format(RPM_ROOT,
                                                         package,
                                                         version),
                     '/build'])
    docker_exec_cmd(docker_exec,
                    ['rpmbuild', '-bb',
                     '--define', 'packagename {0}'.format(package),
                     '--define', 'version {0}'.format(version),
                     '--define', 'irodsversion {0}'.format(irods_version),
                     '/build/{0}.spec'.format(PACKAGE_NAME)])
    docker_exec_cmd(docker_exec,
                    ['rsync',  '-r', '--owner', '--group',
                     '--chown={0}:{1}'.format(os.getuid(), os.getgid()),
                     '{0}/RPMS/'.format(RPM_ROOT),
                     rpm_dir_inside])


if __name__ == '__main__':
    main()
